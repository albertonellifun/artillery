<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, xxxmaximum-scale=1.0, xxxuser-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Artillery - Apple ][ clone</title>

<style>
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
    color: #fff;
    text-shadow: 0 0 2px #0f0, 0 0 4px #0f0;
  }

  #monitor.hantarex {
    width: 100%;
    aspect-ratio: 4 / 3;
    background: url(hantarex.jpg) no-repeat center center;
    background-size: 100% 100%;
  }

  #container.hantarex {
    zoom: 0.5;
    position: relative;
    top: 19%;
    left: 12.5%;
    width: 75%;
    height: 53%;
    overflow: hidden;
    padding: 1%;
  }
  @media (orientation: landscape) {
    #container.hantarex {
      zoom: 0.75;
    }
  }
  

  #container {
    padding: 8px;
    box-sizing: border-box;
    justify-content: space-evenly;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100vw;
    height: 100vh;
    box-shadow: 0 0 10px rgba(0, 100, 0, 1) inset;
    overflow: hidden;
  }

  canvas {
    display: block;
    margin: 0 auto;
    border: 4px solid #fff;
    image-rendering: pixelated;
    background: black;
    aspect-ratio: 320 / 200;
    max-width: 100%;
    height: auto;
  }

  .note {
    font-family: monospace;
    font-size: 16px;
    text-align: center;
    margin: 0;
    color: #fff;
  }
  
  #scanlines-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    background: repeating-linear-gradient(to right, transparent, transparent 0px, rgba(0, 0, 0, 0.33) 2px, transparent 4px);
    background-size: 100% 4px;
    opacity: 1;
    display:none;
    z-index: 10;
  }
  
  #touch-controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 2px 8px;
    width: 100%;
    font-family: monospace;
    font-size: 16px;
  }
  #touch-controls button {
    font-family: monospace;
    font-size: 14px;
    padding: 4px 6px;
    background: #111;
    color: #0f0;
    border: 1px solid #0f0;
    flex: 1 1 80px;
    min-width: 80px;
    overflow: hidden;
    text-shadow: 0 0 2px #0f0, 0 0 4px #0f0;
    white-space: nowrap;
  }
  #touch-controls p {
    flex: 1 1 80px;
    min-width: 80px;
    overflow: hidden;
    text-shadow: 0 0 2px #0f0, 0 0 4px #0f0;
  }
  #touch-controls button:active {
    background: #0f0;
    color: #000;
  }
  #touch-controls button.on {
    background: #0f0 !important;
    color: #000;
    text-shadow: 0 0 4px #000;
  }
  #touch-controls button.c0 {
    background-color: #000;
  }
  #touch-controls button.c1 {
    background-color: #040;
  }
  .full {
    flex: 1 1 100%;
  }
</style>
</head>
<body>
<div id="monitor">
  <div id="container">
    <div id="scanlines-overlay"></div>
  
    <div id="title" class="note">Artillery - Apple ][ clone</div>
    <!-- apple2=280x192, CGA=320x200, alberto=420x200 -->
    <canvas id="game" width="420" height="200"></canvas>
  
    <div id="touch-controls">
      <p id="controls-label">CONTROLS:</p>
      <button type="button" class="c1" data-act="left">&lt;-<br/>ANGLE−</button>
      <button type="button" class="c1" data-act="angle">A<br/>ANGLE</button>
      <button type="button" class="c1" data-act="right">-&gt;<br/>ANGLE+</button>
      
      <button type="button" class="c0" data-act="power-down">↓<br/>POWER−</button>
      <button type="button" class="c0" data-act="power">P<br/>POWER</button>
      <button type="button" class="c0" data-act="power-up">↑<br/>POWER+</button>
      
      <button type="button" class="c1" data-act="fire">(SPACE)<br/>FIRE</button>
      <button type="button" class="c0" data-act="reset">R<br/>RESET</button>
      
      <button type="button" class="c1" data-act="p2human" id="p2humanBtn">H<br/>P2 HUMAN</button>
      <button type="button" class="c0" data-act="mute"    id="muteBtn">M<br/>MUTE</button>
      <div class="full"></div>
      
      <button type="button" class="c1" data-act="scanlines" id="scanlinesBtn">S<br/>SCANLINES</button>
      <button type="button" class="c0 on" data-act="bw"     id="bwBtn">W<br/>B/W PLAYERS</button>
      <button type="button" class="c1" data-act="crt"       id="crtBtn">C<br/>CRT SWITCH</button>
      
      <button type="button" class="c0" data-act="hantarex" id="hantarexBtn">X<br/>HANTAREX MODE</button>
      <button type="button" class="c1" data-act="distort"  id="distortBtn">D<br/>DISTORT MODE</button>
      <button type="button" class="c0" data-act="parallax" id="parallaxBtn">L<br/>PARALLAX MODE</button>
      <button type="button" class="c1" data-act="bang"     id="bangBtn">B<br/>BANG! BANG!</button>
      <button type="button" class="c0" data-act="gorilla"  id="gorillaBtn">G<br/>GORILLA.BAS</button>
      <button type="button" class="c1" data-act="fps"      id="fpsBtn">F</br>FPS</button>
    </div>
  </div>
</div>

<script type="text/javascript">
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');//alpha false fa caos con la distorsione
const W = canvas.width;
const H = canvas.height;

// Mantiene il rapporto originale (320x200)
function resizeCanvas() {
  const aspect = W / H;
  const maxW = document.documentElement.clientWidth - 20;
  const maxH = document.documentElement.clientHeight - 140;
  
  let newW = maxW;
  let newH = newW / aspect;
  if (newH > maxH) {
    newH = maxH;
    newW = newH * aspect;
  }
  
  canvas.style.width = `${newW}px`;
  canvas.style.height = `${newH}px`;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();



// Palette Apple II–style
const COLORS = {
  white: '#FFF', black: '#000',
  gray: '#666', darkGray: '#444',
  green: '#0A0', darkGreen: '#080',
  cyan: '#8CF', darkCyan: '#6AD',
  purple: '#C8F', darkPurple: '#A6D',
  yellow: '#FF8', darkYellow: '#DD6',
  orange: '#F80', darkOrange: '#D60',
  red: '#A00', darkRed: '#800',
  blue: '#00A', darkBlue: '#008',
  darkestGreen : '#050', 
  lightGray: '#AAA',
  lightGreen: '#0C0',
  lightCyan: '#AEF',
  lightPurple: '#EAF',
  lightYellow: '#FFA',
  lightOrange: '#FA2',
  lightRed: '#C22',
  lightBlue: '#2BF',
};

let titles = { default : 'Artillery - Apple ][ clone', gorilla : 'Gorilla.bas for MS-DOS clone', bang : 'Bang! Bang! for Windows 3.1 clone' };

let terrain = new Uint8Array(W);
let projectile = null;
let message = '';
let frame = 0;

// players
const players = [
  { name:"PLAYER 1", color: COLORS.cyan,   darkColor: COLORS.darkCyan,   lightColor: COLORS.lightCyan,   x:25,     angle:60, power:50, isAI:false },
  { name:"PLAYER 2", color: COLORS.purple, darkColor: COLORS.darkPurple, lightColor: COLORS.lightPurple, x:W - 45, angle:60, power:50, isAI:true }
];

let currentPlayer = 0;
let wind = 0;
let gameover = true;
const gravity = 0.05;//9.8

const keys = {};
let inputMode = null; // "angle" o "power" per gestire A+n numeri=angle, P+n numeri=power
let inputBuffer = "";

const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Assicurati che sia definito una sola volta


let isMute = false;//perche' il silenzio e' d'oro
let scanLinesEnabled = false;//a noi piacciono i monitor vintage
let currentCrt = 0;//effetti speciali (arancione, bianco e nero, verde, etc...)
let isHantarex = false;//mostra o nasconde il mitico hantarex 12 pollici a fosfori verdi che ti ammazza le diottrie
let isBW = true;//apple2 aveva tutto bianco, terreno verde
let isDistort = false;//prova a renderizzare il canvas in modalita' boccia per pesciolini
let isBang = false;//bang! bang! per windows 3.1 ;)
let isGorilla = false;//gorilla.bas su qbasic ;) ;)
let isParallax = false;//sfumature e terreno tipo parallasse... figata anacronistica assoluta!

//fps per delfini curiosi e cavalli golosi...
let lastTime = performance.now();
let fps = 0;
let isFps = false;
let minFps = 9999;


// ------------------------------------------------
// TERRAIN GENERATION
let terrainColors = [ COLORS.green, COLORS.darkGreen,
                      COLORS.red, COLORS.darkRed,
                      COLORS.cyan, COLORS.darkCyan,
                      COLORS.purple, COLORS.darkPurple,
                      COLORS.orange, COLORS.darkOrange,
                      COLORS.gray, COLORS.darkGray,
                      COLORS.yellow, COLORS.darkYellow ];
let currentTerrainColor = -2;
let currentTerrainColorDark = -1;

function genTerrain() { 
  //random color
  currentTerrainColor = (currentTerrainColor + 2) % terrainColors.length;
  currentTerrainColorDark = currentTerrainColor + 1;

  //random shape
  const terrainGenerators = [ genTerrainPicco, genTerrainGradino, genTerrainDune  ];
  const randomIndex = (Math.random() * terrainGenerators.length) | 0;
  terrainGenerators[randomIndex]();

  //appiattisce terreno sotto la bandiera come sul gioco originale
  const flagX = W - 15;  
  for(let i=flagX-5;i<W;i++) { 
    terrain[i] = terrain[flagX-5]; 
  }
  
  //arrotonda i picchi
  if(randomIndex !== 0) roundTerrain();
  
  //squadra per i palazzi da 40px
  if(isGorilla) roundTerrainGorilla();
}

//arrotondamento leggero del terreno
function roundTerrain() { 
  for (let i = 1; i < W - 1; i++) {
    terrain[i] = Math.round((terrain[i - 1] + terrain[i] + terrain[i + 1]) / 3);
  }
}

//squadramento da 40px e multipli di 14px (finestra)
function roundTerrainGorilla() {
  for (let i = 0; i < W; i += 40) {
    terrain[i] = ( (terrain[i] / 14) |0 ) * 14 + 1;
	if (Math.random() < 0.01) terrain[i] = 170;//random palazzone di 12 piani
    
	if (i>0 && terrain[i] == terrain[i-1]) terrain[i] = terrain[i] + (Math.random() < 0.5 ? -14 : 14);
	
	if (terrain[i] > 170) terrain[i] = 170;	
	if (terrain[i] < 14) terrain[i] = 14;//altezza minima 14px = 1 finestra
    
    for(let j = 1;j < 40;j++) {
      terrain[i+j] = terrain[i];
    }
  }
}

//due dune
function genTerrainDune() {
  const baseHeight = 80 + Math.random() * 30; // altezza media del terreno
  const amplitude = 10 + Math.random() * 30;   // intensità delle ondulazioni
  const slopeFactor = (Math.random() * 0.2) - 0.1; // pendenza verso destra o sinistra random
  const dune = (Math.random() * 10) < 5 ? 30 : 20;

  for (let x = 0; x < W; x++) {
    // Collina dolce con pendenza verso destra e leggere ondulazioni
    const slope = x * slopeFactor;
    const wave = Math.sin(x / dune) * amplitude;
    const height = baseHeight - slope + wave;

    terrain[x] = Math.max(6, Math.min(H - 40, Math.round(height)));
  }
}

//picco al centro (parabola o iperbole)
function genTerrainPicco() {
  // Assumi che W (larghezza), H (altezza) e terrain siano definiti
  // e che terrain sia un array di lunghezza W (e.g., let terrain = new Uint8Array(W);)
  const altoASinistra = Math.random() < 0.5;
  const piccoParabolico = Math.random() < 0.5;
  
  const baseHeightLeft = (altoASinistra ? 120 : 40 ) + Math.random() * 20;
  const baseHeightRight = (altoASinistra? 40 : 120) + (Math.random() * 30 - 15);
  const stepX = Math.floor(W / 2); // Centro del picco

  // Parametri del Picco
  const PEAK_HEIGHT = 20 + Math.random() * 20; // Altezza massima aggiuntiva del picco (tra 80 e 120)
  const PEAK_WIDTH = 30; // Larghezza base del picco (più piccolo è, più è appuntito)

  for (let x = 0; x < W; x++) {
    let height;

    // 1. Calcola l'altezza di base (i lati piatti)
    if (x < stepX) {
      // Lato sinistro: pianeggiante con leggere ondulazioni
      height = baseHeightLeft + Math.sin(x / 20) * 3;
    } else {
      // Lato destro: più alto e ondulato
      height = baseHeightRight + Math.sin(x / 20) * 3;
    }

    // 2. Aggiungi la forma del Picco Centrale (Parabola o Iperbole)
    const distanceToCenter = Math.abs(x - stepX);

    if (distanceToCenter < PEAK_WIDTH && ((x >= stepX && !altoASinistra) || (x < stepX && altoASinistra))) {
      let mountainHeight = 0;
      if(piccoParabolico) {
        // Calcola quanto siamo lontani dal centro (ratio va da 0 a 1)
        const ratio = distanceToCenter / PEAK_WIDTH;
        // Funzione parabolica (1 - ratio^2) per creare un picco a forma di collina
        mountainHeight = PEAK_HEIGHT * (1 - ratio * ratio);
      }
      else {
        const safeDistance = Math.max(distanceToCenter, 1); // evita 1/0
        const inverseFalloff = 1 / (safeDistance/2); // più vicino al centro = valore più alto
	    // Normalizza l'inverseFalloff tra 0 e 1
        const maxInverse = 1 / 1;         // quando distance = 1
        const minInverse = 1 / PEAK_WIDTH; // quando distance = PEAK_WIDTH
        const normalized = (inverseFalloff - minInverse) / (maxInverse - minInverse);
      
        mountainHeight = PEAK_HEIGHT * normalized;
      }
    
      // Sovrapponi il picco all'altezza di base.
      height += mountainHeight;
    }

    // 3. Clamping e Arrotondamento
    // Il limite superiore è H - 40 per lasciare spazio sotto, 6 è il limite superiore dello schermo
    terrain[x] = Math.max(6, Math.min(H - 40, Math.round(height)));
  }
}

//scalino al centro
function genTerrainGradino() {
  const baseHeightLeft = 40 + Math.random() * 20;
  const baseHeightRight = 120 + (Math.random() * 30 - 15);
  const stepX = Math.floor(W / 2); // posizione del gradino

  for (let x = 0; x < W; x++) {
    let height;

    if (x < stepX) {
      // lato sinistro: pianeggiante con leggere ondulazioni
      height = baseHeightLeft + Math.sin(x / 25) * 4;
    } else if (x  === stepX) {
      // gradino verticale
      height = (baseHeightLeft + baseHeightRight) / 2;
    } else {
      // lato destro: più alto e ondulato
      height = baseHeightRight + Math.sin(x / 25) * 4;
    }

    terrain[x] = Math.max(6, Math.min(H - 40, Math.round(height)));
  }
}

//vento
function randomizeWind() {
  wind = Math.floor(Math.random() * 21) - 10;
}


//reset
function reset() {  
  genTerrain();
  randomizeWind();
  projectile = null;
  message = '';
  currentPlayer = 0;
  gameover = false;
}

reset();




// ------------------------------------------------
// LAUNCH PROJECTILE
function launch(player) {
  if (projectile) return;
  playShootSound();
  
  let a = player.angle * Math.PI / 180;
  let v = gravity * player.power;
  let vx = v * Math.cos(a) * (player.x < W/2 ? 1 : -1);
  let vy = -v * Math.sin(a);
  projectile = {
    x: player.x,
    y: (H - terrain[player.x]) - 2,
    vx: vx,
    vy: vy,
    ax: wind/1000,
    ay: gravity,
    owner: player
  };
}

// ------------------------------------------------
// EXPLOSION
function explode(x, y, radius) {
  playExplosionSound(); 

  //crea un cratere
  const ix = Math.floor(x);
  for (let dx = -radius-1; dx <= radius+1; dx++) {
    const sx = ix + dx;
    if (sx < 0 || sx >= W) continue;
    const dist = Math.abs(dx);
    if (dist <= radius) {
      //const drop = Math.round((radius - dist) * (0.8 + Math.random()*0.4));//buco a V
      const factor = 1 - ((dist/radius)*(dist/radius));//buco a parabola
      const drop = Math.round(radius * factor * (0.8 + Math.random()*0.4));
    
    terrain[sx] = Math.max(0, terrain[sx] - drop);
    }
  }
  
  //controlla se colpisce un cannone
  for (let p of players) {
    const px = p.x;
  const py = H - terrain[p.x];
    const dist = Math.hypot(x - px, y - py);//ipotenusa == radice (a^2 + b^2)
    
    //controlliamo TUTTI i giocatori
    if (dist < radius + 4) {
        
        //se un giocatore è stato colpito
        if(isGorilla) playGorillaVictory(); else playTankExplosionSound(); 
    
    spawnCannonExplosion(px,py,p.color);

        const isSelfHit = p === projectile.owner;
        const targetName = isSelfHit ? "HIMSELF" : p.name;
        const attackerName = projectile.owner.name;

        message = `${attackerName} DESTROYS ${targetName}!`;
        projectile = null;
    gameover = true;
        
        //fine del gioco/Reset se un cannone è stato colpito
        setTimeout(reset, isGorilla ? 4000 : 3000); 
        return;
    }
  }
  
  //fine turno
  projectile = null;
  nextTurn();
}

//gestione esplosione cannone
let explosions = []; // elenco esplosioni colorate attive
function spawnCannonExplosion(px, py, pcolor) {
  const colors = isBW ? [COLORS.white, COLORS.green, COLORS.darkGreen] : [COLORS.white, COLORS.yellow, COLORS.orange, pcolor];
  for (let i = 0; i < 18; i++) {
    const angle = Math.PI + (Math.PI / 18) * i;
    const speed = Math.random() * 1;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    explosions.push({
    ox : px,
    oy : py,
      x: px,
      y: py,
      vx: vx,
      vy: vy,
      life: 40 + Math.random() * 40,//frame di durata
      color: colors[i % colors.length]
    });
  }
}


// ------------------------------------------------
// TURN MANAGEMENT
function nextTurn() {
  currentPlayer = (currentPlayer + 1) % players.length;
  randomizeWind();
  if (players[currentPlayer].isAI) {
    setTimeout(aiShoot, 2000);
  }
}

// IA molto semplice: stima direzione e spara con potenza casuale
function aiShoot() {
  const ai = players[currentPlayer];
  const target = players[0];
  const dx = (target.x - ai.x);
  ai.angle = (60 + Math.random()*30) | 0;//int
  ai.power = Math.min(100, Math.abs(dx)/3 + Math.random()*10) | 0;
  launch(ai);
}


// ------------------------------------------------
// UPDATE LOOP
function update() {
  frame++;

  const p = players[currentPlayer];
  if (!p.isAI) {
    if (keys['ArrowRight']) p.angle = (Math.max(0, p.angle + (currentPlayer ? 1 : -1))) | 0;
    if (keys['ArrowLeft']) p.angle = (Math.min(180, p.angle + (currentPlayer ? -1 : 1))) | 0;
    if (keys['ArrowUp']) p.power = (Math.min(100, p.power + 1)) | 0;
    if (keys['ArrowDown']) p.power = (Math.max(5, p.power - 1)) | 0;
    if (keys[' '] ) { launch(p); keys[' '] = false; }
  }

  // aggiorna proiettile
  if (projectile) {
    projectile.vx += projectile.ax;
    projectile.vy += projectile.ay;
    projectile.x += projectile.vx;
    projectile.y += projectile.vy;
  
  const xidx = Math.floor(projectile.x);
    if (xidx >= 0 && xidx < W) {
      const groundY = H - terrain[xidx];
      if (projectile.y >= groundY) {
        explode(projectile.x, projectile.y, 10);
    projectile = null;
    }
    }
    if (projectile && (projectile.x < -50 || projectile.x > W+50 || projectile.y > H+50)) {
      projectile = null;
    nextTurn();
    }
  }
  
  // aggiorna esplosioni radiali
  for (let i = explosions.length - 1; i >= 0; i--) {
    const e = explosions[i];
    e.x += e.vx;
    e.y += e.vy;
    e.life--;
    if (e.life <= 0) explosions.splice(i, 1);
  }
}



//black or blue?
function clearSky() {
  if(isParallax) {
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, isBang ? COLORS.darkCyan : isGorilla ? COLORS.darkBlue : COLORS.black);
    gradient.addColorStop(1, isBang ? COLORS.white : isGorilla ? COLORS.lightBlue : COLORS.gray);
    ctx.fillStyle = gradient;
  } else {
    ctx.fillStyle = isBang ? COLORS.darkCyan : isGorilla ? COLORS.darkBlue : COLORS.black;
  }
  ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = COLORS.white;
  ctx.strokeRect(0,0,W,H);
}

//ghghgh
function drawSkyAccessories() {
  //BANG ha le nuvolette + sole
  //GORILLA ha solo il SOLE
  if(isBang) {
    let currentTime = new Date();
    let currentTimeMMSS = currentTime.getMinutes() * 60 + currentTime.getSeconds();//W/2 + minuti + secondi
    let posx = (W/2 + currentTimeMMSS);
    
    let sunx = (posx / 10) % W | 0;
    let c1x = (40 + (posx / 3)) % W  | 0;
    let c2x = (70 + (posx / 4)) % W | 0;
    let c3x = (100 + (posx / 5)) % W | 0;
    let c4x = (140 + (posx / 4)) % W | 0;
    let c5x = (160 + (posx / 3)) % W | 0;
    
    if(currentTime.getHours() > 19) {
      //luna
      drawMoon(sunx, 20, 10);
      //nuvole
      drawCloud(c3x, 25, 0.25, 1);
      drawCloud(c4x, 25, 0.35, 3);
      drawCloud(c5x, 30, 0.25, 2);
    } else {
      //sole
      let ooo = projectile != null && Math.abs(projectile.x - sunx) < 10 && Math.abs(projectile.y - 20) < 10;
      drawSun(sunx, 20, 10, ooo, 8);
      //nuvole
      drawCloud(c1x, 25, 0.25, 1);
      drawCloud(c2x, 35, 0.45, 2);
      drawCloud(c3x, 25, 0.35, 3);
      drawCloud(c4x, 30, 0.55, 1);
      drawCloud(c5x, 30, 0.25, 2);
      //uccelli
      for(var i=0;i<3;i++) {  
        drawBird((60 + i*W/3 + c1x) % W, 30 + i*2);
        drawBird((75 + i*W/3 + c1x) % W, 44 + i*2);
        drawBird((90 + i*W/3 + c1x) % W, 35 - i*2);
      }
    }
  } else if(isGorilla) {
    let currentTime = new Date();
    let currentTimeMMSS = currentTime.getMinutes() * 60 + currentTime.getSeconds();//W/2 + minuti + secondi
    let posx = (W/2 + currentTimeMMSS);
  
    let sunx = (posx / 10) % W | 0;
  
    if(currentTime.getHours() > 19) {
      //luna
      drawMoon(sunx, 20, 10);
    } else {
      //sole
      let ooo = projectile != null && Math.abs(projectile.x - sunx) < 10 && Math.abs(projectile.y - 20) < 10;
      drawSun(sunx, 20, 9, ooo, 16);
    }
  }
}

// ------------------------------------------------
// DRAW
function draw() {
  //clear
  clearSky();

  //sun/clouds/birds/etc...
  drawSkyAccessories();
    
  //terrain
  if(isGorilla) drawTerrainGorilla();
  else if(isBang) drawTerrainBang();
  else drawTerrain();
  
  //flag
  drawWindFlag();
 

  //players
  players.forEach(p => drawGun(p));
  
  
  //disegna projectile
  if (projectile) {
    if(isBang) drawProjectileBang();//palla
    else if(isGorilla) drawProjectileBanana();//banana
    else drawProjectile();//missiletto standard
  }
  
  //disegna esplosioni radiali
  for (const e of explosions) {
    ctx.strokeStyle = e.color;
    ctx.beginPath();
    ctx.moveTo(e.ox, e.oy);
    ctx.lineTo(e.x, e.y);
    ctx.stroke();
  }

  //hud
  drawHUD();
}

//disegna palla da cannone
function drawProjectileBang() {
  ctx.fillStyle = COLORS.gray;
  ctx.strokeStyle = COLORS.darkGray;
  ctx.beginPath();
  ctx.arc(projectile.x, projectile.y, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
}

//disegna projectile
function drawProjectile() {
  //scia
  ctx.strokeStyle = isBW ? COLORS.green : projectile.owner.color;
  ctx.beginPath();
  ctx.moveTo(projectile.x, projectile.y);
  //+ avanti tipo missile con razzo dietro, - con punta bianca e scia colorata (mahhh)
  ctx.lineTo(projectile.x + projectile.vx * 2, projectile.y + projectile.vy * 2);
  ctx.stroke();
  //punta
  ctx.fillStyle = COLORS.white;
  ctx.fillRect(projectile.x-1, projectile.y-1, 2,2);
}

//disegna banana!!!
function drawProjectileBanana() {
  const angle = Math.atan2(projectile.vy, projectile.vx);
  ctx.save();
  ctx.translate(projectile.x, projectile.y);
  ctx.rotate(angle);
  const length = 8;//lunghezza totale
  const thickness = 0.5;//distanza tra arco esterno e interno
  ctx.beginPath();
  ctx.strokeStyle = COLORS.yellow;
  ctx.lineWidth = 1;
  ctx.moveTo(-length/2, -thickness);
  ctx.quadraticCurveTo(0, -length, length/2, -thickness);
  ctx.moveTo(-length/2, thickness);
  ctx.quadraticCurveTo(0, -length/2, length/2, thickness);
  ctx.stroke();
  ctx.restore();
}

//disegna terreno
function drawTerrain() {
  for (let x=0;x<W;x++){
    const h = terrain[x];
  
    if(isBW) {
      if(isParallax) {
        const gradient = ctx.createLinearGradient(x, 0, x, H);
        gradient.addColorStop(0, COLORS.green);
        gradient.addColorStop(1, COLORS.darkestGreen);
        ctx.fillStyle = (x % 2 === 0 || scanLinesEnabled) ? gradient : COLORS.darkestGreen;
      } else {    
        ctx.fillStyle = (x % 2 === 0 || scanLinesEnabled) ? COLORS.green : COLORS.darkGreen;
      }
    }
    else {
      if(isParallax) {
        const gradient = ctx.createLinearGradient(x, 0, x, H);
        gradient.addColorStop(0, terrainColors[currentTerrainColor]);
        gradient.addColorStop(1, terrainColors[currentTerrainColorDark]);
        ctx.fillStyle = (x % 2 === 0 || scanLinesEnabled) ? gradient : terrainColors[currentTerrainColorDark];
      } else {
        ctx.fillStyle = (x % 2 === 0 || scanLinesEnabled) ? terrainColors[currentTerrainColor] : terrainColors[currentTerrainColorDark];
      }
    }
    
    ctx.fillRect(x, H - h, 1, h);
    
    if(isParallax && x > 0 && terrain[x] <= terrain[x-1] || Math.abs(terrain[x] - terrain[x-1]) > 2) {
      const gradient = ctx.createLinearGradient(x + 1, H - h, x + 15, H - h);
      gradient.addColorStop(0, isBang ? COLORS.darkestGreen : isBW ? COLORS.darkestGreen : terrainColors[currentTerrainColorDark]);
      gradient.addColorStop(1, isBang ? COLORS.green : isBW ? COLORS.darkGreen : terrainColors[currentTerrainColor]);
      ctx.fillStyle = gradient;
      //rettangolare
      //ctx.fillRect(x + 1, H - h, 15, h);
	  //trapezio
      ctx.beginPath();
      ctx.moveTo(x + 1, H - h);          // vertice sinistro alto
      ctx.lineTo(x + 1 + 20, H - h + 10); // vertice destro alto (più in su di 10px)
      ctx.lineTo(x + 1 + 20, H);          // vertice destro basso
      ctx.lineTo(x + 1, H);               // vertice sinistro basso
      ctx.closePath();
      ctx.fill();
    }
  }
}

//disegna terreno bang
function drawTerrainBang() {
  for (let x=0;x<W;x++){
    const h = terrain[x];
    
    if(isParallax) {
	  //sfumatura terreno
      const gradient = ctx.createLinearGradient(x, 0, x, H);
      gradient.addColorStop(0, COLORS.lightGreen);
	  gradient.addColorStop(1, COLORS.darkestGreen);
      ctx.fillStyle = gradient;
    } else {
      ctx.fillStyle = COLORS.green;
    }
    
    ctx.fillRect(x, H - h, 1, h);
	
	/*
	//paesaggio doppio sfumato xxxxxx
	const gradient = ctx.createLinearGradient(x, 0, x, H);
    gradient.addColorStop(0, "rgba(255,255,255,0.33)");//COLORS.green);
	gradient.addColorStop(1, "rgba(0,0,0,0)");//COLORS.darkGreen);	
    ctx.fillStyle = gradient;
	ctx.fillRect(x, H - h + 10, 1, h + 10);
	*/
    
    //bordo scuro
    ctx.fillStyle = isParallax ? COLORS.darkestGreen : COLORS.darkGreen;
    ctx.fillRect(x, H - h, 1, 1);
    
    if(isParallax && x > 0 && terrain[x] <= terrain[x-1] || Math.abs(terrain[x] - terrain[x-1]) > 2) {
      const gradient = ctx.createLinearGradient(x + 1, H - h, x + 15, H - h);
      gradient.addColorStop(0, isBang ? COLORS.darkestGreen : isBW ? COLORS.darkestGreen : terrainColors[currentTerrainColorDark]);
      gradient.addColorStop(1, isBang ? COLORS.green : isBW ? COLORS.darkGreen : terrainColors[currentTerrainColor]);
      ctx.fillStyle = gradient;
	  //rettangolare
      //ctx.fillRect(x + 1, H - h, 15, h);
	  //trapezio
      ctx.beginPath();
      ctx.moveTo(x + 1, H - h);           // vertice sinistro alto
      ctx.lineTo(x + 1 + 20, H - h + 10); // vertice destro alto (più in giu di 10px)
      ctx.lineTo(x + 1 + 20, H);          // vertice destro basso
      ctx.lineTo(x + 1, H);               // vertice sinistro basso
      ctx.closePath();
      ctx.fill();
    }
  }
}

//disegna i palazzi (ogni palazzo largo 40px)
const windowMap = {}; //memorizza lo stato di ogni finestra
function drawTerrainGorilla() {
  for (let x=0;x<W;x++) {
  const palazzo = (x/40) | 0;//1..n
  
  palazzoColor = (palazzo * 2) % terrainColors.length;  
  ctx.fillStyle = terrainColors[palazzoColor];
  
  const h = terrain[x];
  ctx.fillRect(x, H - h, 1, h);
  
  if(isParallax && x%40 == 39) {
    const gradient = ctx.createLinearGradient(x, H - h, x + 15, H);
    gradient.addColorStop(0, terrainColors[palazzoColor]);
    gradient.addColorStop(0.5, terrainColors[palazzoColor + 1]);
    gradient.addColorStop(1, COLORS.lightBlue);
    ctx.fillStyle = gradient;
  
    //trapezio
    ctx.beginPath();
    ctx.moveTo(x, H - h);          // vertice sinistro alto
    ctx.lineTo(x + 20, H - h + 10); // vertice destro alto (più in su di 10px)
    ctx.lineTo(x + 20, H);          // vertice destro basso
    ctx.lineTo(x, H);               // vertice sinistro basso
    ctx.closePath();
    ctx.fill();
  }
  
  
  let mod = x%40;
  
  let f1 = mod > 2 && mod < 8;
  let f2 = mod > 12 && mod < 18;
  let f3 = mod > 22 && mod < 28;
  let f4 = mod > 32 && mod < 38;
  
  if( f1 || f2 || f3 || f4) {
    let floor = -1;
    //disegna dal basso -> finestre sempre rettangolari
    //disegna dall'alto -> finestre disastrate :-)
    for (let y = H /*H - h + 4*/; 
       y >= H - h /*y < H*/;
       y -= 14 /* y += 14 */) {
      floor++;
      ctx.beginPath()
      
      //accensione random
      const windowKey = `${palazzo}_${f1}_${f2}_${f3}_${f4}_${floor}`;
      if (!(windowKey in windowMap) || Math.random() < 0.00001) {
        let accesa = Math.random();
        windowMap[windowKey] =  accesa < 0.1 ? COLORS.white : 
                                accesa < 0.5 ? COLORS.lightYellow : 
                                accesa < 0.9 ? COLORS.black : 
                                COLORS.darkGray;
      }
      
      ctx.strokeStyle = windowMap[windowKey];
      ctx.moveTo(x, y + 1 );
      ctx.lineTo(x, y + 11);
      ctx.stroke();
      }
    }
  }
}

//disegna cannoni
function drawGun(p) {
  const y = (H - terrain[p.x]) - 2;

  if (isBang) {
    //cannoncino 
    drawCannoneBang(p, y);
  } else if(isGorilla) {
    //gestione lancio + esplosione
    let armType = 3;//giu
    let isLauncing = projectile && projectile.owner == p;//braccio su
    let isExploding = explosions && explosions.length;//braccio su alternato
    
    if(isExploding) {
      armType = ((new Date().getMilliseconds()*4)/1000|0) % 2 == 0 ? 1 : 2;//0..1000 -> 0..3999 -> 0..3 -> 1/2/1/2
    } else if(isLauncing) {
      armType = 1;
    }
    drawGorilla(p, y-19, armType, 0.66);
  } else {
    //carro armato apple2
    drawCannoneLegacy(p, y);
  }
}

//carro armato brutto
function drawCannoneLegacy(p, y) {
  // CORPO del cannone: trapezio rovesciato
    ctx.fillStyle = isBW ? COLORS.white : p.color;
    ctx.beginPath();
    ctx.moveTo(p.x - 5, y);     // punto in alto a sinistra
    ctx.lineTo(p.x + 5, y);     // punto in alto a destra
    ctx.lineTo(p.x + 4, y + 3); // punto in basso a destra
    ctx.lineTo(p.x - 4, y + 3); // punto in basso a sinistra
    ctx.closePath();
    ctx.fill();
    if (isBW) {
      // era nero dentro
      ctx.strokeStyle = COLORS.black;
      ctx.beginPath();
      ctx.moveTo(p.x - 3, y + 1.5);
      ctx.lineTo(p.x + 3, y + 1.5);
      ctx.stroke();
    }  
      
    // CANNA del cannone doppia
    const a = p.angle * Math.PI / 180;
    const len = 6;
    const dir = (p.x < W/2 ? 1 : -1);
    const bx = p.x + Math.cos(a) * len * dir;
    const by = y - Math.sin(a) * len;
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.moveTo(p.x-1, y);
    ctx.lineTo(bx-1, by);
    ctx.lineTo(bx+1, by);
    ctx.lineTo(p.x+1, y);
    ctx.strokeStyle = isBW ? COLORS.white : p.color;
    ctx.stroke();
}

//cannone vintage cicciotto
function drawCannoneBang(p, y) {
  //CANNA: cilindro inclinato con bordo arrotondato
  const a = p.angle * Math.PI / 180;
  const len = 6;
  const dir = (p.x < W/2 ? 1 : -1);
  const bx = p.x + Math.cos(a) * len * dir;
  const by = y - Math.sin(a) * len;
  const thickness = 8;
  //supposta 2.0
  ctx.save();
  ctx.translate(p.x, y);
  ctx.rotate(-a * dir);
  ctx.strokeStyle = COLORS.darkGray;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, -thickness / 2);
  ctx.lineTo(len * dir, -thickness / 2);
  ctx.arc(len * dir, 0, thickness / 2, -Math.PI / 2, Math.PI / 2, dir < 0);
  ctx.lineTo(0, thickness / 2);
  ctx.arc(0, 0, thickness / 2, Math.PI / 2, -Math.PI / 2, dir < 0);
  ctx.closePath();
  
  if(isParallax) {
    //ombra interna gradiente
    const grad = ctx.createLinearGradient(0, -thickness / 2, 0, thickness / 2);
    grad.addColorStop(0, isBW ? COLORS.lightGray : p.lightColor);
    grad.addColorStop(1, COLORS.darkGray);
    ctx.fillStyle = grad;
  } else {
    //grigione
    ctx.fillStyle = isBW ? COLORS.gray : p.color;
  }
  ctx.fill();
  ctx.stroke();
  ctx.restore();  
  
  //BASE: rettangoli uno sopra l'altro
  ctx.fillStyle = COLORS.black;
  ctx.fillRect(p.x - 4, y, 8, 2);  
  ctx.fillRect(p.x - 5, y + 2, 10, 2);  
  ctx.fillRect(p.x - 6, y + 4, 12, 2);  
  //asse di rotazione
  ctx.fillStyle = COLORS.darkGray;
  ctx.fillRect(p.x - 2,y - 1, 4, 4);
  ctx.fillStyle = COLORS.gray;
  ctx.fillRect(p.x - 1,y, 2, 2);
  
  //ombra cannone
  if(isParallax) drawShadow(p.x, y, 12)
}

function drawShadow(x, y, shadowRadius) {
  ctx.save();
  const shadowRadiusY = shadowRadius * 0.2;	//raggio sfumatura verticale, schiacciata!
  const deltay = y + 4;		//spostato sotto di 4px
  const shadowGrad = ctx.createRadialGradient(x + 4, deltay, 0, x + 4, deltay, shadowRadius);
  shadowGrad.addColorStop(0, "rgba(0,0,0,0.33)"); // centro più scuro
  shadowGrad.addColorStop(1, "rgba(0,0,0,0)");   // bordi trasparenti
  ctx.fillStyle = shadowGrad;
  ctx.beginPath();
  ctx.ellipse(x, deltay, shadowRadius, shadowRadiusY, 0, 0, 2 * Math.PI);
  ctx.fill();
  ctx.restore();
}

//gorilla!
function drawGorilla(p, y, arms = 3, scale = 0.5) {
    const S = (v) => v * scale;//scala
  const x = p.x;

    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = isBW ? COLORS.orange : p.color;
    ctx.strokeStyle = isBW ? COLORS.darkOrange : p.darkColor;
    ctx.lineWidth = 1;

    // --- HEAD ---
  ctx.fillRect(S(-4), S(0), S(6.9), S(6)); // fronte + occhi
    ctx.fillRect(S(-5), S(2), S(9), S(2));   // mento

  // Brow line
    ctx.beginPath();
    ctx.moveTo(S(-3), S(2));
    ctx.lineTo(S(2), S(2));
    ctx.stroke();

    // Nose (optional)
    ctx.fillRect(S(-2), S(4), 1, 1);
    ctx.fillRect(S(1), S(4), 1, 1);

    // Neck line
    ctx.beginPath();
    ctx.moveTo(S(-3), S(7));
    ctx.lineTo(S(2), S(7));
    ctx.stroke();

    // --- BODY ---
    ctx.fillRect(S(-8), S(8), S(14.9), S(6));   // upper torso
    ctx.fillRect(S(-6), S(15), S(10.9), S(5));  // lower torso

    // --- CHEST SHADING ---
    ctx.beginPath();
    ctx.arc(S(-4.9), S(10), S(4.9), 1.5 * Math.PI, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(S(4.9), S(10), S(4.9), Math.PI, 1.5 * Math.PI);
    ctx.stroke();

    // --- LEGS ---
    for (let i = 0; i <= 4; i++) {
        ctx.beginPath();
        ctx.arc(S(i), S(25), S(10), 3 * Math.PI / 4, 9 * Math.PI / 8);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(S(-6 + i - 0.1), S(25), S(10), 15 * Math.PI / 8, Math.PI / 4);
        ctx.stroke();
    }

    // --- ARMS ---
    for (let i = -5; i <= -1; i++) {
        if (arms === 1) {
            // Right arm up
            ctx.beginPath();
            ctx.arc(S(i - 0.1), S(14), S(9), 3 * Math.PI / 4, 5 * Math.PI / 4);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(S(4.9 + i), S(4), S(9), 7 * Math.PI / 4, Math.PI / 4);
            ctx.stroke();
        } else if (arms === 2) {
            // Left arm up
            ctx.beginPath();
            ctx.arc(S(i - 0.1), S(4), S(9), 3 * Math.PI / 4, 5 * Math.PI / 4);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(S(4.9 + i), S(14), S(9), 7 * Math.PI / 4, Math.PI / 4);
            ctx.stroke();
        } else {
            // Both arms down
            ctx.beginPath();
            ctx.arc(S(i - 0.1), S(14), S(9), 3 * Math.PI / 4, 5 * Math.PI / 4);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(S(4.9 + i), S(14), S(9), 7 * Math.PI / 4, Math.PI / 4);
            ctx.stroke();
        }
    }

    ctx.restore();
}


//disegna bandiera
function drawWindFlag() {
  const flagX = W - 15;
  const flagY = H - terrain[flagX];//altezza del terreno in quel punto
  
  //disegna asta
  ctx.strokeStyle = isBang ? COLORS.darkGray : COLORS.white;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(flagX, flagY);
  if(isBang || isGorilla) ctx.lineTo(flagX, flagY - 20);
  else ctx.lineTo(flagX, flagY - 12);
  ctx.stroke();

  //disegna bandiera
  let windIntensity = Math.abs(wind) | 0;
  const rectWidth = windIntensity;
  const rectHeight = 5;

  if(isBang) {
    if (wind >= 0) {
      //bandiera verso destra, parte alta
      ctx.fillStyle = isBW ? COLORS.white : COLORS.yellow;
      ctx.fillRect(flagX, flagY - 18, rectWidth / 2, rectHeight);
      ctx.strokeStyle = COLORS.darkGray;
      ctx.strokeRect(flagX, flagY - 18, rectWidth / 2, rectHeight);
      // bandiera verso destra → punta rientrante verso l’asta
      ctx.moveTo(flagX + 2, flagY - 12);                          // attacco asta (alto)
      ctx.lineTo(flagX + 2 + rectWidth, flagY - 12);              // bordo alto
      ctx.lineTo(flagX + 2 + rectWidth - 3, flagY - 12 + rectHeight / 2); // taglio triangolare interno
      ctx.lineTo(flagX + 2 + rectWidth, flagY - 12 + rectHeight); // bordo basso
      ctx.lineTo(flagX + 2, flagY - 12 + rectHeight);             // ritorno all’asta
    } else {
      //bandiera verso sinistra, parte alta
      ctx.fillStyle = isBW ? COLORS.white : COLORS.yellow;
      ctx.fillRect(flagX - rectWidth / 2, flagY - 18, rectWidth / 2, rectHeight);
      ctx.strokeStyle = COLORS.darkGray;
      ctx.strokeRect(flagX - rectWidth / 2, flagY - 18, rectWidth / 2, rectHeight);
      // bandiera verso sinistra → punta rientrante verso l’asta
      ctx.moveTo(flagX - 2, flagY - 12);                          // attacco asta (alto)
      ctx.lineTo(flagX - 2 - rectWidth, flagY - 12);              // bordo alto
      ctx.lineTo(flagX - 2 - rectWidth + 3, flagY - 12 + rectHeight / 2); // taglio triangolare interno
      ctx.lineTo(flagX - 2 - rectWidth, flagY - 12 + rectHeight); // bordo basso
      ctx.lineTo(flagX - 2, flagY - 12 + rectHeight);             // ritorno all’asta
    }
    ctx.fillStyle = isBW ? COLORS.white : COLORS.yellow;
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  } else {
    if (wind >= 0) {
      //bandiera verso destra
      ctx.fillStyle = isBW ? COLORS.white : COLORS.yellow;
      ctx.fillRect(flagX, flagY - (isGorilla ? 18 : 12), rectWidth, rectHeight);
    } else {
      //bandiera verso sinistra
      ctx.fillStyle = isBW ? COLORS.white : COLORS.yellow;
      ctx.fillRect(flagX - rectWidth, flagY - (isGorilla ? 18 : 12), rectWidth, rectHeight);
    }
  }
  
  //ombra bandiera
  if(isParallax && isBang) drawShadow(flagX, flagY - 2, 8)  
}

//disegna dati player
function drawHUD() {
  const p = players[currentPlayer];
  
  if(isGorilla) {
  ctx.fillStyle = COLORS.darkBlue;
  ctx.fillRect(0, H-11, W, H-1);
  }
  
  ctx.font = "10px monospace";
  ctx.textBaseline = "alphabetic";
  ctx.fillStyle = isBW ? COLORS.white : p.color;  
  
  //turno corrente
  ctx.fillStyle = COLORS.white;
  ctx.fillText("TURN: ", 6, H - 2);
  ctx.fillStyle = isBW ? COLORS.white : p.color;
  ctx.fillText(p.name, 39, H - 2);
  
  //potenza/angolo
  ctx.fillStyle = COLORS.white;
  ctx.fillText("POWER: " + p.power, 100, H - 2);
  ctx.fillText("ANGLE: " + p.angle, 170, H - 2);
  
  //vento
  ctx.fillText("WIND: " + (wind > 0 ? '+':'') + wind, W - 52, H - 2);
  

  //messaggio
  if (message) {
    const tw = ctx.measureText(message).width;
  if(isGorilla) {
    ctx.fillStyle = COLORS.darkBlue;
    ctx.fillRect((W-tw) / 2 - 2, H - 20, tw + 2, 11);
  }
  ctx.fillStyle = COLORS.white;
    ctx.fillText(message, (W - tw)/2, H - 12);
  }
  
  //titolo dentro con bordi doppi
  if (isDistort) {
    ctx.fillStyle = COLORS.white;//gray;
    const title = isGorilla ? titles.gorilla : isBang ? titles.bang : titles.default;
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (W - tw)/2, 14);
    ctx.strokeStyle = COLORS.white;
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, W, H);
    ctx.strokeStyle = COLORS.gray;
    ctx.lineWidth = 1;
    ctx.strokeRect(3, 3, W-3, H-3);
  }
}



//SUONI
function playExplosionSound() {
  if(isMute) return;
    const now = audioCtx.currentTime;

    // 1. Crea un generatore di Rumore Bianco (Noise Buffer)
    const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 secondi
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      output[i] = Math.random() * 2 - 1; // Riempie il buffer con rumore casuale (statico)
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    // 2. Crea i nodi di Guadagno e Filtro
    const noiseGain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    // Imposta il filtro per un suono "sordo" e breve (filtro passa basso)
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, now); // Frequenza di taglio iniziale
    filter.frequency.exponentialRampToValueAtTime(10, now + 0.3); // Decadimento rapido della frequenza

    // Connessioni: Rumore -> Filtro -> Guadagno -> Destinazione
    noise.connect(filter);
    filter.connect(noiseGain);
    noiseGain.connect(audioCtx.destination);

    // 3. Envelope (ADSR)
    noiseGain.gain.setValueAtTime(0.5, now); // Volume iniziale
    // Decay rapido del volume (il "botto" finisce subito)
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3); 

    // 4. Avvia e Ferma
    noise.start(now);
    noise.stop(now + 0.3);
}

function playShootSound() {
  if(isMute) return;
    // 1. Crea l'oscillatore (il "generatore di suono")
    const oscillator = audioCtx.createOscillator();
    // Usa un'onda quadra per un suono "pixelato" o un'onda a dente di sega (sawtooth)
    oscillator.type = 'square'; 

    // 2. Crea un nodo del guadagno (Gain Node) per controllare il volume e l'ADSR
    const gainNode = audioCtx.createGain();
    
    // Connetti: Oscillatore -> Guadagno -> Destinazione (altoparlanti)
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    // 3. Imposta la Frequenza Iniziale e Finale (per il "pitch-drop" o "fall")
    const startFreq = 400; // Frequenza iniziale (più alta)
    const endFreq = 200;   // Frequenza finale (più bassa)
    const duration = 0.15; // Durata breve in secondi

    oscillator.frequency.setValueAtTime(startFreq, now);
    // Diminuisci rapidamente la frequenza (effetto laser/sparo 8-bit)
    oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

    // 4. Imposta il Volume (Envelope)
    gainNode.gain.setValueAtTime(0.5, now); // Volume iniziale
    // Riduci rapidamente il volume
    gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); 
    
    // 5. Avvia e Ferma l'oscillatore
    oscillator.start(now);
    oscillator.stop(now + duration);
}

function playTankExplosionSound() {
  if(isMute) return;
    const now = audioCtx.currentTime;
    const duration = 0.5; // Durata maggiore per l'esplosione del carro armato

    // 1. Rumore Bianco (Il "Bot")
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1; 
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const noiseGain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.frequency.exponentialRampToValueAtTime(10, now + duration);

    noise.connect(filter);
    filter.connect(noiseGain);
    
    // 2. Tono Basso (L'effetto "WAAAH")
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'sawtooth'; // Tono più ricco di armoniche
    
    const oscGain = audioCtx.createGain();
    
    // Connessioni per il Tono:
    oscillator.connect(oscGain);

    // Envelope del Tono: Pitch Drop
    oscillator.frequency.setValueAtTime(100, now); // Frequenza iniziale bassa
    oscillator.frequency.exponentialRampToValueAtTime(10, now + duration); // Crolla a 10Hz

    // 3. Unione e Decadimento del Guadagno
    
    // Volume del Rumore
    noiseGain.gain.setValueAtTime(0.6, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + duration); 

    // Volume del Tono
    oscGain.gain.setValueAtTime(0.3, now);
    oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration); 

    // Unisci i due suoni e invia alla destinazione
    noiseGain.connect(audioCtx.destination);
    oscGain.connect(audioCtx.destination);

    // 4. Avvia e Ferma
    noise.start(now);
    noise.stop(now + duration);
    oscillator.start(now);
    oscillator.stop(now + duration);
}

function playBeep() {
  if(isMute) return;
  if(isGorilla) { playGorillaMelody(); return; }
  const oscillator = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  oscillator.type = 'square'; // Apple II usava un'onda quadra
  oscillator.frequency.setValueAtTime(935, audioCtx.currentTime);
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);

  oscillator.connect(gain);
  gain.connect(audioCtx.destination);

  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.1); // durata 250 ms
}

//gorilla beep :-)
const noteFreq = {
  'c': 261.63 / 2, 
  'd': 293.66 / 2, 
  'e': 329.63 / 2,
  'f': 349.23 / 2, 
  'g': 392.00 / 2, 
  'a': 440.00 / 2, 
  'b': 493.88 / 2,
  'C': 261.63, 
  'D': 293.66, 
  'E': 329.63,
  'F': 349.23, 
  'G': 392.00, 
  'A': 440.00, 
  'B': 493.88
};

function playTone(freq, duration, audioCtx, time) {
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.type = 'square';
  oscillator.frequency.value = freq;
  oscillator.start(time);
  oscillator.stop(time + duration);
}


function playGorillaMelody(forceMelody = "", forceLen = "", forceNoteTime = 1/16) {
  if(isMute) return;
  const melody   = forceMelody ? forceMelody : "CDEDCDECC";
  const noteLen  = forceLen ?       forceLen : "222222444";
  const noteTime = forceNoteTime ? forceNoteTime : 1 / 16;
  
  let currentTime = audioCtx.currentTime;

  for (let i = 0; i < melody.length; i++) {
  const note = melody[i];
  const duration = noteTime * noteLen[i];
    if (noteFreq[note]) {
      playTone(noteFreq[note]/2, duration, audioCtx, currentTime);
	  console.log(note+'='+noteFreq[note]/2);
  }
  currentTime += duration;
  }
}

function playGorillaVictory() {
  if(isMute) return;
  const melody  = "EFGEFDC_EFGEFDC_EFGEFDC_EFGEFDC_EFGEFDC";
  const noteLen = "111111111111111111111111111111111111111";
  playGorillaMelody(melody, noteLen, 1/32);
}




//gestione scanlines on/off
function changeScanLines() {
  scanLinesEnabled = !scanLinesEnabled;
  const btn = document.getElementById('scanlinesBtn');
  
  if (scanLinesEnabled) {
    btn.classList.add('on');
    document.getElementById('scanlines-overlay').style.display = 'block';
  } else {
    btn.classList.remove('on');
    document.getElementById('scanlines-overlay').style.display = 'none';
  }
}





// ------------------------------------------------
// QUESTO E' IL GIOCO!
function loop(timeStamp) {
  update();
  draw();
  if(isDistort) distort();
  
  //fps
  if(isFps) {
    const delta = timeStamp - lastTime;
    fps = (1000 / delta) | 0;
    if (fps < minFps && fps > 2) minFps = fps;
    ctx.fillStyle = COLORS.white;
    ctx.font = '10px monospace';
    ctx.fillText(`FPS: ${fps} - min: ${minFps}`, 2, 10);
    lastTime = timeStamp;
  }
  
  requestAnimationFrame(loop);
}

loop();



//gestione mute sound on/off  
function changeMute() {
  isMute = !isMute;
  const btn = document.getElementById('muteBtn');

  if (isMute) btn.classList.add('on');
  else btn.classList.remove('on');
}

//gestione P2 umano
function changePlayer2Human() {
  players[1].isAI = !(players[1].isAI);
  const btn = document.getElementById('p2humanBtn');
  
  if(players[1].isAI) btn.classList.remove('on');
  else btn.classList.add('on');
}


//gestione crt
function changeCrt() {
  currentCrt = (currentCrt+1) % 4;
  const btn = document.getElementById('crtBtn');
  const container = document.getElementById('container');
  
  if(currentCrt == 0) {
    btn.classList.remove('on');
    container.style.filter = '';
  }
  else if(currentCrt == 1) {
    //fosfori arancioni
    btn.classList.add('on');
    container.style.filter = 'hue-rotate(280deg)';
  }
  else if(currentCrt == 2) {
    //fosfori blu
    btn.classList.add('on');
    container.style.filter = 'hue-rotate(80deg)';
  }
  else {
    //bianco e nero :(
    btn.classList.add('on');
    container.style.filter = 'grayscale(1)';
  }
}


//gestione hantarex
function changeHantarex() {
    isHantarex = !isHantarex;
  const btn = document.getElementById('hantarexBtn');
  const monitor = document.getElementById('monitor');
  const container = document.getElementById('container');
  
  if (isHantarex) {
    btn.classList.add('on');
    monitor.classList.add('hantarex');
    container.classList.add('hantarex');
  }
  else {
    btn.classList.remove('on');
    monitor.classList.remove('hantarex');
    container.classList.remove('hantarex');
  }
}


//gestione bw
function changeBW() {
  isBW = !isBW;
  const btn = document.getElementById('bwBtn');
  
  if (isBW) {
    btn.classList.add('on');
  }
  else {
    btn.classList.remove('on');
  }
}


//gestione distort
function changeDistort() {
  isDistort = !isDistort;
  const btn = document.getElementById('distortBtn');
  const title = document.getElementById('title');
  const game = document.getElementById('game');
  
  if (isDistort) {
    btn.classList.add('on');
    title.style.display = 'none';
    game.style.border = 'none';
  }
  else {
    btn.classList.remove('on');
    title.style.display = 'block';
    game.style.border = '4px solid #fff';
  }
}

//gestione fps
function changeFps() {
  isFps = !isFps;
  const btn = document.getElementById('fpsBtn');
  
  if (isFps) {
	minFps = 9999;
    btn.classList.add('on');
  }
  else {
    btn.classList.remove('on');
  }
}

//gestione parallax
function changeParallax() {
  isParallax = !isParallax;
  const btn = document.getElementById('parallaxBtn');
  
  if (isParallax) {
    btn.classList.add('on');
  }
  else {
    btn.classList.remove('on');
  }
}

// ------------------------------------------------
// INPUT
window.addEventListener('keydown', e => {
  const key = e.key;
  const keyLC = key.toLowerCase();
  
  //alcuni devono funzionare sempre
  switch(keyLC) {
    case ' ' : e.preventDefault(); break;
    case 's' : changeScanLines(); break;
    case 'm' : changeMute(); break;
    case 'c' : changeCrt(); break;
    case 'x' : changeHantarex(); break;
    case 'w' : changeBW(); break;
    case 'd' : changeDistort(); break;
    case 'b' : changeBang(); break;
    case 'g' : changeGorilla(); break;
    case 'f' : changeFps(); break;
    case 'l' : changeParallax(); break;
  }
  
  //altri devono funzionare solo quando tocca all'umano
  if (players[currentPlayer].isAI) return;
  if (gameover) return;

  switch(keyLC) {
    case 'r': reset(); playBeep(); break;
    case 'h': changePlayer2Human(); break;
    case 'a': enterAngle(); break;
    case 'p': enterPower(); break;
  }

  keys[key] = true;
});

//popup orrenda angolo
function enterAngle() {
    let aa = prompt('ENTER ANGLE (0-180)');
  const value = parseInt(aa);
    const p = players[currentPlayer];
    p.angle = Math.max(0, Math.min(180, value)) | 0;
}

//popup orrenda potenza
function enterPower() {
  let pp = prompt('ENTER POWER (0-100)');
  const value = parseInt(pp);
    const p = players[currentPlayer];
    p.power = Math.max(5, Math.min(100, value)) | 0;
}

window.addEventListener('keyup', e=>{ keys[e.key] = false });

//click = spara!
canvas.addEventListener('click', ()=> {
  if (gameover) return;
  if (!players[currentPlayer].isAI) launch(players[currentPlayer]);
});

//doppio click = fullscreen
document.getElementById('controls-label').addEventListener('dblclick', () => {
  if(document.fullscreenElement) document.exitFullscreen();
  else document.documentElement.requestFullscreen();
});

//gestione touch controls
document.getElementById('touch-controls').addEventListener('click', e => {
  //alcuni devono funzionare sempre
  const btn = e.target.closest('button');
  if (!btn) return;
  const act = btn.dataset.act;
  const p = players[currentPlayer];

  switch (act) {
    case 'mute': changeMute(); break;
    case 'scanlines': changeScanLines(); break;
    case 'crt': changeCrt(); break;
    case 'hantarex': changeHantarex(); break;
    case 'bw': changeBW(); break;
    case 'distort': changeDistort(); break;
    case 'bang': changeBang(); break;
    case 'gorilla': changeGorilla(); break;
    case 'parallax': changeParallax(); break;
    case 'fps': changeFps(); break;
  }
  
  //altri devono funzionare solo quando tocca all'umano
  if (players[currentPlayer].isAI) return;
  if (gameover) return;
  
  switch (act) {
    case 'left':  p.angle = Math.min(180, p.angle + (currentPlayer ? -1 : 1)); break;
    case 'right': p.angle = Math.max(0, p.angle - (currentPlayer ? -1 : 1)); break;
    case 'power-up':   p.power = Math.min(100, p.power + 5); break;
    case 'power-down': p.power = Math.max(5, p.power - 5); break;
    case 'fire': launch(p); break;
    case 'reset': reset(); playBeep(); break;
    case 'p2human': changePlayer2Human(); break;
    case 'power': enterPower(); break;
    case 'angle': enterAngle(); break;
  }
  
  btn.blur();
});


// ora applichiamo distorsione a barilotto
function distort() {    
    const src = ctx.getImageData(0, 0, W, H);
    const dst = ctx.createImageData(W, H);

    const k = -0.00000125; //intensità curvatura (più grande = più curva, a me ne basta un infinitesimo)
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        const dx = x - W / 2;
        const dy = y - H / 2;
        const r2 = dx * dx + dy * dy;
        const factor = 1 + k * r2; //fattore di curvatura
        const sx = Math.round(W / 2 + dx / factor);
        const sy = Math.round(H / 2 + dy / factor);
        if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
          const sIdx = (sy * W + sx) * 4;
          const dIdx = (y * W + x) * 4;
          dst.data[dIdx] = src.data[sIdx];
          dst.data[dIdx + 1] = src.data[sIdx + 1];
          dst.data[dIdx + 2] = src.data[sIdx + 2];
          dst.data[dIdx + 3] = src.data[sIdx + 3];
        }
      }
    }

    ctx.putImageData(dst, 0, 0);
}

//gorilla.bas
function changeGorilla() {
  isGorilla = !isGorilla;
  const btn = document.getElementById('gorillaBtn');
  const game = document.getElementById('game');
  const title = document.getElementById('title');
  
  if (isGorilla) {
    reset();
    playBeep();
    btn.classList.add('on');
    game.style.filter = 'contrast(1.3) saturate(1.3)';
    title.innerHTML = titles.gorilla;
  } else {
    reset();
    playBeep();
    btn.classList.remove('on');
    game.style.filter = '';
    title.innerHTML = isBang ? titles.bang : titles.default;
  }
}


//bang!
function changeBang() {
  isBang = !isBang;
  const btn = document.getElementById('bangBtn');
  const game = document.getElementById('game');
  const title = document.getElementById('title');
  
  if (isBang) {
    btn.classList.add('on');
    game.style.filter = 'contrast(1.3) saturate(1.3)';
    title.innerHTML = titles.bang;
  }
  else {
    btn.classList.remove('on');
    game.style.filter = '';
    title.innerHTML = isGorilla ? titles.gorilla : titles.default;
  }
}

function drawCloud(x, y, scale = 0.5, cloudType = 3) {
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x, y);
  
  switch(cloudType) {
  case 1 : 
    ctx.bezierCurveTo(x - 10 * scale, y - 10 * scale, x + 10 * scale, y - 25 * scale, x + 30 * scale, y - 10 * scale);
    ctx.bezierCurveTo(x + 45 * scale, y - 25 * scale, x + 70 * scale, y - 15 * scale, x + 60 * scale, y);
    ctx.bezierCurveTo(x + 80 * scale, y + 5 * scale, x + 50 * scale, y + 15 * scale, x + 25 * scale, y + 10 * scale);
    ctx.bezierCurveTo(x + 10 * scale, y + 15 * scale, x - 5 * scale, y + 10 * scale, x, y);
    break;
    
  case 2 :
    ctx.bezierCurveTo(x + 10 * scale, y - 20 * scale, x + 40 * scale, y - 25 * scale, x + 50 * scale, y - 10 * scale);
    ctx.bezierCurveTo(x + 65 * scale, y - 30 * scale, x + 100 * scale, y - 20 * scale, x + 90 * scale, y);
    ctx.bezierCurveTo(x + 110 * scale, y - 5 * scale, x + 120 * scale, y + 10 * scale, x + 100 * scale, y + 15 * scale);
    ctx.bezierCurveTo(x + 80 * scale, y + 20 * scale, x + 40 * scale, y + 15 * scale, x + 20 * scale, y + 10 * scale);
    ctx.bezierCurveTo(x + 5 * scale, y + 15 * scale, x - 5 * scale, y + 5 * scale, x, y);
    break;
    
  case 3 : 
    ctx.bezierCurveTo(x + 10 * scale, y - 15 * scale, x + 35 * scale, y - 25 * scale, x + 45 * scale, y - 10 * scale);
    ctx.bezierCurveTo(x + 55 * scale, y - 30 * scale, x + 85 * scale, y - 20 * scale, x + 75 * scale, y);
    ctx.bezierCurveTo(x + 95 * scale, y - 5 * scale, x + 105 * scale, y + 15 * scale, x + 90 * scale, y + 20 * scale);
    ctx.bezierCurveTo(x + 70 * scale, y + 25 * scale, x + 40 * scale, y + 20 * scale, x + 20 * scale, y + 15 * scale);
    ctx.bezierCurveTo(x + 5 * scale, y + 20 * scale, x - 5 * scale, y + 10 * scale, x, y);
    break;
  }
  
  ctx.closePath();
  if(isParallax) {
    const gradient = ctx.createLinearGradient(x-5*scale, y-30*scale, x+110*scale, y+20*scale);
    gradient.addColorStop(0, COLORS.lightGray);
    gradient.addColorStop(1, COLORS.white);
    ctx.fillStyle = gradient;
  } else {
	ctx.fillStyle = COLORS.white;
  }
  ctx.strokeStyle = COLORS.gray;
  ctx.lineWidth = scale * 2;
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawSun(x, y, radius = 10, ooo = false, rays = 8) {
  //disco giallo
  if(isParallax) {
    const gradient = ctx.createLinearGradient(x-radius, y-radius, x+radius, y+radius);
    gradient.addColorStop(0, COLORS.lightYellow);
    gradient.addColorStop(1, COLORS.lightOrange);
    ctx.fillStyle = gradient;
  } else {
	ctx.fillStyle = COLORS.yellow;
  }
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  
  //bordo scuro
  ctx.strokeStyle = COLORS.darkYellow;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();
  
  //raggi
  ctx.strokeStyle = COLORS.yellow;
  ctx.lineWidth = 1;
  for (let i = 0; i < rays; i++) {
    const angle = (i * 2 * Math.PI) / rays;
    const x1 = x + Math.cos(angle) * radius;
    const y1 = y + Math.sin(angle) * radius;
    const x2 = x + Math.cos(angle) * (radius + 5);
    const y2 = y + Math.sin(angle) * (radius + 5);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  
  drawSunFace(x, y, radius, ooo);
}

function drawSunFace(x, y, radius = 10, ooo = false) {
  //occhi
  const eyeOffsetX = radius * 0.4;
  const eyeOffsetY = radius * 0.3;
  const eyeRadius = 1.8;
  ctx.fillStyle = COLORS.darkGray;
  ctx.beginPath();
  ctx.arc(x - eyeOffsetX, y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
  ctx.arc(x + eyeOffsetX, y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
  ctx.fill();
  //naso
  ctx.beginPath();
  ctx.moveTo(x, y - 1);
  ctx.lineTo(x, y + 1);
  ctx.strokeStyle = COLORS.darkGray;
  ctx.lineWidth = 1;
  ctx.stroke();
  //bocca
  ctx.beginPath();
  if(ooo) {
    ctx.arc(x, y + radius * 0.4, radius * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.darkGray;
    ctx.fill();
  } else {
    ctx.arc(x, y + radius * 0.1, radius * 0.5, Math.PI * 0.25, Math.PI * 0.75);
    ctx.stroke();
  }
}

function drawMoon(x, y, radius = 10) {
  //disco chiaro
  if(isParallax) {
    const gradient = ctx.createLinearGradient(x-radius, y-radius, x+radius, y+radius);
    gradient.addColorStop(0, COLORS.lightYellow);
    gradient.addColorStop(1, COLORS.lightOrange);
    ctx.fillStyle = gradient;
  } else {
	ctx.fillStyle = COLORS.yellow;
  }
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();

  //bordo bianco
  ctx.strokeStyle = COLORS.white;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();

  //parte in ombra
  ctx.fillStyle = isGorilla ? COLORS.darkBlue : COLORS.darkCyan;
  ctx.beginPath();
  ctx.arc(x + radius / 3, y - radius / 6, radius * 0.85, 0, Math.PI * 2);
  ctx.fill();
}

function drawBird(x, y, size = 6) {
  ctx.strokeStyle = COLORS.darkGray;
  ctx.beginPath();
  //ala sinistra
  ctx.moveTo(x - size, y);
  ctx.quadraticCurveTo(x - size / 2, y - size / 2, x, y);
  //ala destra
  ctx.quadraticCurveTo(x + size / 2, y - size / 2, x + size, y);
  ctx.stroke();
}
</script>
</body>
</html>