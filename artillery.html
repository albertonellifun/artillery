<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, xxxmaximum-scale=1.0, xxxuser-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Artillery - Apple ][ clone</title>

<style>
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
	background: #000;
	color: #fff;
	text-shadow: 0 0 2px #0f0, 0 0 4px #0f0;
  }

  #monitor.hantarex {
    width: 100%;
    aspect-ratio: 4 / 3;
    background: url(hantarex.jpg) no-repeat center center;
    background-size: 100% 100%;
  }

  #container.hantarex {
    zoom: 0.5;
    position: relative;
    top: 19%;
    left: 12.5%;
    width: 75%;
    height: 53%;
    overflow: hidden;
    padding: 1%;
  }
  @media (orientation: landscape) {
	#container.hantarex {
		zoom: 0.75;
	}
  }
  

  #container {
    padding: 8px;
    box-sizing: border-box;
	justify-content: space-evenly;
    display: flex;
    flex-direction: column;
    align-items: center;
	width: 100vw;
	height: 100vh;
	box-shadow: 0 0 10px rgba(0, 100, 0, 1) inset;
  }

  canvas {
    display: block;
    margin: 0 auto;
    border: 4px solid #fff;
    image-rendering: pixelated;
    background: black;
    aspect-ratio: 320 / 200;
    max-width: 100%;
    height: auto;
  }

  .note {
    font-family: monospace;
    font-size: 16px;
    text-align: center;
    margin: 0;
    color: #fff;
  }
  
  #scanlines-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    background: repeating-linear-gradient(transparent, transparent 0px, rgba(0, 0, 0, 0.5) 1px, transparent 2px);
    background-size: 100% 4px;
    opacity: 1;
	display:none;
  }
  
  #touch-controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
	align-items: center;
    gap: 8px;
    margin-top: 10px;
	width: 100%;
	font-family: monospace;
    font-size: 16px;
  }
  #touch-controls button {
    font-family: monospace;
    font-size: 14px;
    padding: 4px 6px;
    background: #111;
    color: #0f0;
    border: 1px solid #0f0;
    flex: 1 1 80px;
    min-width: 80px;
	overflow: hidden;
	text-shadow: 0 0 2px #0f0, 0 0 4px #0f0;
	white-space: nowrap;
  }
  #touch-controls p {
    flex: 1 1 80px;
    min-width: 80px;
	overflow: hidden;
	text-shadow: 0 0 2px #0f0, 0 0 4px #0f0;
  }
  #touch-controls button:active {
    background: #0f0;
    color: #000;
  }
  #touch-controls button.on {
    background: #0f0 !important;
    color: #000;
	text-shadow: 0 0 4px #000;
  }
  #touch-controls button.c0 {
	background-color: #000;
  }
  #touch-controls button.c1 {
	background-color: #040;
  } 
</style>
</head>
<body>
<div id="monitor">
	<div id="container">
		<div id="scanlines-overlay"></div>
  
		<div id="title" class="note">Artillery - Apple ][ clone</div>
		<canvas id="game" width="320" height="200"></canvas>
  
		<div id="touch-controls">
			<p>CONTROLS:</p>
			<button type="button" class="c1" data-act="left">&lt;-<br/>ANGLE−</button>
			<button type="button" class="c1" data-act="angle">A<br/>ANGLE</button>
			<button type="button" class="c1" data-act="right">-&gt;<br/>ANGLE+</button>
			<button type="button" class="c0" data-act="power-up">↑<br/>POWER+</button>
			<button type="button" class="c0" data-act="power">P<br/>POWER</button>
			<button type="button" class="c0" data-act="power-down">↓<br/>POWER−</button>
			<button type="button" class="c1" data-act="fire">(SPACE)<br/>FIRE</button>
			<button type="button" class="c0" data-act="reset">R<br/>RESET</button>
			<button type="button" class="c1" data-act="p2human" id="p2humanBtn">H<br/>P2 HUMAN</button>
			<button type="button" class="c0" data-act="mute" id="muteBtn">M<br/>MUTE</button>
			<button type="button" class="c1" data-act="scanlines" id="scanlinesBtn">S<br/>SCANLINES</button>
			<button type="button" class="c0" data-act="bw" id="bwBtn">B<br/>B/W MODE</button>
			<button type="button" class="c1" data-act="crt" id="crtBtn">C<br/>CRT MODE</button>
			<button type="button" class="c0" data-act="hantarex" id="hantarexBtn">X<br/>HANTAREX MODE</button>
			<button type="button" class="c1" data-act="distort" id="distortBtn">D<br/>DISTORT MODE</button>
		</div>
	</div>
</div>

<script type="text/javascript">
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {xxxalpha: false});
const W = canvas.width;
const H = canvas.height;

// Mantiene il rapporto originale 16:10 (320x200)
function resizeCanvas() {
  const aspect = W / H;
  const maxW = document.documentElement.clientWidth - 20;
  const maxH = document.documentElement.clientHeight - 140;
  
  let newW = maxW;
  let newH = newW / aspect;
  if (newH > maxH) {
    newH = maxH;
    newW = newH * aspect;
  }
  
  canvas.style.width = `${newW}px`;
  canvas.style.height = `${newH}px`;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();



// Palette Apple II–style
const COLORS = {
  white: '#FFF', black: '#000',
  gray: '#666', darkGray: '#444',
  green: '#0A0', darkGreen: '#080',
  cyan: '#8CF', darkCyan: '#6AD',
  purple: '#C8F', darkPurple: '#A6D',
  yellow: '#FF8', darkYellow: '#DD6',
  orange: '#F80', darkOrange: '#D60'  
};


let terrain = new Uint8Array(W);
let projectile = null;
let message = '';
let frame = 0;

// players
const players = [
  { name:"PLAYER 1", color: COLORS.cyan,   x:30,  angle:60, power:50, isAI:false },
  { name:"PLAYER 2", color: COLORS.purple, x:280, angle:60, power:50, isAI:true }
];

let currentPlayer = 0;
let wind = 0;
let gameover = true;
const gravity = 0.05;//9.8

const keys = {};
let inputMode = null; // "angle" o "power" per gestire A+n numeri=angle, P+n numeri=power
let inputBuffer = "";

const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Assicurati che sia definito una sola volta


let isMute = false;//perche' il silenzio e' d'oro
let scanLinesEnabled = false;//a noi piacciono i monitor vintage
let currentCrt = 0;//effetti speciali (arancione, bianco e nero, verde, etc...)
let isHantarex = false;//mostra o nasconde il mitico hantarex 12 pollici a fosfori verdi che ti ammazza le diottrie
let isBW = false;//apple2 aveva tutto bianco, terreno verde
let isDistort = false;//prova a renderizzare il canvas in modalita' boccia per pesciolini

// ------------------------------------------------
// TERRAIN GENERATION
let terrainColors = [ COLORS.green, COLORS.darkGreen, 
	COLORS.orange, COLORS.darkOrange, 
	COLORS.gray, COLORS.darkGray,
	COLORS.yellow, COLORS.darkYellow, 
	COLORS.cyan, COLORS.darkCyan, 
	COLORS.purple, COLORS.darkPurple];
let currentTerrainColor = -2;
let currentTerrainColorDark = -1;

function genTerrain() { 
	//random color
	currentTerrainColor = (currentTerrainColor + 2) % terrainColors.length;
	currentTerrainColorDark = currentTerrainColor + 1;

	//random shape
	const terrainGenerators = [ genTerrainPicco, genTerrainGradino, genTerrainDune  ];
	const randomIndex = (Math.random() * terrainGenerators.length) | 0;
	terrainGenerators[randomIndex]();

	//appiattisce terreno sotto la bandiera come sul gioco originale
	const flagX = players[1].x + 25;  
	for(let i=flagX-5;i<W;i++) { 
		terrain[i] = terrain[flagX-5]; 
	}
	
	//arrotonda i picchi
	if(randomIndex !== 0) roundTerrain();
}

//arrotondamento leggero del terreno
function roundTerrain() { 
  for (let i = 1; i < W - 1; i++) {
    terrain[i] = Math.round((terrain[i - 1] + terrain[i] + terrain[i + 1]) / 3);
  }
}

//due dune
function genTerrainDune() {
  const baseHeight = 80 + Math.random() * 30; // altezza media del terreno
  const amplitude = 10 + Math.random() * 30;   // intensità delle ondulazioni
  const slopeFactor = (Math.random() * 0.2) - 0.1; // pendenza verso destra o sinistra random
  const dune = (Math.random() * 10) < 5 ? 30 : 20;

  for (let x = 0; x < W; x++) {
    // Collina dolce con pendenza verso destra e leggere ondulazioni
    const slope = x * slopeFactor;
    const wave = Math.sin(x / dune) * amplitude;
    const height = baseHeight - slope + wave;

    terrain[x] = Math.max(6, Math.min(H - 40, Math.round(height)));
  }
}

//picco al centro (parabola o iperbole)
function genTerrainPicco() {
  // Assumi che W (larghezza), H (altezza) e terrain siano definiti
  // e che terrain sia un array di lunghezza W (e.g., let terrain = new Uint8Array(W);)
  const altoASinistra = Math.random() < 0.5;
  const piccoParabolico = Math.random() < 0.5;
  
  const baseHeightLeft = (altoASinistra ? 120 : 40 ) + Math.random() * 20;
  const baseHeightRight = (altoASinistra? 40 : 120) + (Math.random() * 30 - 15);
  const stepX = Math.floor(W / 2); // Centro del picco

  // Parametri del Picco
  const PEAK_HEIGHT = 20 + Math.random() * 20; // Altezza massima aggiuntiva del picco (tra 80 e 120)
  const PEAK_WIDTH = 30; // Larghezza base del picco (più piccolo è, più è appuntito)

  for (let x = 0; x < W; x++) {
    let height;

    // 1. Calcola l'altezza di base (i lati piatti)
    if (x < stepX) {
      // Lato sinistro: pianeggiante con leggere ondulazioni
      height = baseHeightLeft + Math.sin(x / 20) * 3;
    } else {
      // Lato destro: più alto e ondulato
      height = baseHeightRight + Math.sin(x / 20) * 3;
    }

    // 2. Aggiungi la forma del Picco Centrale (Parabola o Iperbole)
    const distanceToCenter = Math.abs(x - stepX);

    if (distanceToCenter < PEAK_WIDTH && ((x >= stepX && !altoASinistra) || (x < stepX && altoASinistra))) {
	  let mountainHeight = 0;
	  if(piccoParabolico) {
		// Calcola quanto siamo lontani dal centro (ratio va da 0 a 1)
		const ratio = distanceToCenter / PEAK_WIDTH;
		// Funzione parabolica (1 - ratio^2) per creare un picco a forma di collina
		mountainHeight = PEAK_HEIGHT * (1 - ratio * ratio);
	  }
	  else {
		const safeDistance = Math.max(distanceToCenter, 1); // evita 1/0
		const inverseFalloff = 1 / (safeDistance/2); // più vicino al centro = valore più alto

		// Normalizza l'inverseFalloff tra 0 e 1
		const maxInverse = 1 / 1;         // quando distance = 1
		const minInverse = 1 / PEAK_WIDTH; // quando distance = PEAK_WIDTH
		const normalized = (inverseFalloff - minInverse) / (maxInverse - minInverse);
		
		mountainHeight = PEAK_HEIGHT * normalized;
      }
	  
      // Sovrapponi il picco all'altezza di base.
      height += mountainHeight;
    }

    // 3. Clamping e Arrotondamento
    // Il limite superiore è H - 40 per lasciare spazio sotto, 6 è il limite superiore dello schermo
    terrain[x] = Math.max(6, Math.min(H - 40, Math.round(height)));
  }
}

//scalino al centro
function genTerrainGradino() {
  const baseHeightLeft = 40 + Math.random() * 20;
  const baseHeightRight = 120 + (Math.random() * 30 - 15);
  const stepX = Math.floor(W / 2); // posizione del gradino

  for (let x = 0; x < W; x++) {
    let height;

    if (x < stepX) {
      // lato sinistro: pianeggiante con leggere ondulazioni
      height = baseHeightLeft + Math.sin(x / 25) * 4;
    } else if (x  === stepX) {
      // gradino verticale
      height = (baseHeightLeft + baseHeightRight) / 2;
    } else {
      // lato destro: più alto e ondulato
      height = baseHeightRight + Math.sin(x / 25) * 4;
    }

    terrain[x] = Math.max(6, Math.min(H - 40, Math.round(height)));
  }
}

//vento
function randomizeWind() {
  wind = Math.floor(Math.random() * 21) - 10;
}


//reset
function reset() {  
  genTerrain();
  randomizeWind();
  projectile = null;
  message = '';
  currentPlayer = 0;
  gameover = false;
}

reset();




// ------------------------------------------------
// LAUNCH PROJECTILE
function launch(player) {
  if (projectile) return;
  playShootSound();
  
  let a = player.angle * Math.PI / 180;
  let v = gravity * player.power;
  let vx = v * Math.cos(a) * (player.x < W/2 ? 1 : -1);
  let vy = -v * Math.sin(a);
  projectile = {
    x: player.x,
    y: (H - terrain[player.x]) - 2,
    vx: vx,
    vy: vy,
    ax: wind/1000,
    ay: gravity,
    owner: player
  };
}

// ------------------------------------------------
// EXPLOSION
function explode(x, y, radius) {
  playExplosionSound(); 

  // crea un piccolo cratere
  const ix = Math.floor(x);
  for (let dx = -radius-1; dx <= radius+1; dx++) {
    const sx = ix + dx;
    if (sx < 0 || sx >= W) continue;
    const dist = Math.abs(dx);
    if (dist <= radius) {
      //const drop = Math.round((radius - dist) * (0.8 + Math.random()*0.4));//buco a V
      const factor = 1 - ((dist/radius)*(dist/radius));//buco a parabola
      const drop = Math.round(radius * factor * (0.8 + Math.random()*0.4));
	  
	  terrain[sx] = Math.max(0, terrain[sx] - drop);
    }
  }
  
  // controlla se colpisce un cannone
  for (let p of players) {
    const px = p.x;
	const py = H - terrain[p.x];
    const dist = Math.hypot(x - px, y - py);//ipotenusa == radice (a^2 + b^2)
    
    // Controlliamo TUTTI i giocatori
    if (dist < radius + 4) {
        
        // Se un giocatore è stato colpito
        playTankExplosionSound(); 
		spawnCannonExplosion(px,py);

        const isSelfHit = p === projectile.owner;
        const targetName = isSelfHit ? "HIMSELF" : p.name;
        const attackerName = projectile.owner.name;

        message = `${attackerName} DESTROYS ${targetName}!`;
        projectile = null;
		gameover = true;
        
        // Fine del gioco/Reset se un cannone è stato colpito
        setTimeout(reset, 3000); 
        return;
    }
  }
  
  // fine turno
  projectile = null;
  nextTurn();
}

//gestione esplosione cannone
let explosions = []; // elenco esplosioni colorate attive
function spawnCannonExplosion(px, py) {
  const colors = isBW ? [COLORS.white, COLORS.green, COLORS.darkGreen] : [COLORS.white, COLORS.yellow, COLORS.purple, COLORS.cyan];
  for (let i = 0; i < 10; i++) {
    const angle = Math.PI + (Math.PI / 10) * i;
    const speed = Math.random() * 1;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    explosions.push({
      x: px,
      y: py,
      vx: vx,
      vy: vy,
      life: 40 + Math.random() * 40, // frame di durata
      color: colors[i % colors.length]
    });
  }
}


// ------------------------------------------------
// TURN MANAGEMENT
function nextTurn() {
  currentPlayer = (currentPlayer + 1) % players.length;
  randomizeWind();
  if (players[currentPlayer].isAI) {
    setTimeout(aiShoot, 2000);
  }
}

// IA molto semplice: stima direzione e spara con potenza casuale
function aiShoot() {
  const ai = players[currentPlayer];
  const target = players[0];
  const dx = (target.x - ai.x);
  ai.angle = (60 + Math.random()*30) | 0;//int
  ai.power = Math.min(100, Math.abs(dx)/3 + Math.random()*10) | 0;
  launch(ai);
}

// ------------------------------------------------
// UPDATE LOOP
function update() {
  frame++;

  const p = players[currentPlayer];
  if (!p.isAI) {
    if (keys['ArrowRight']) p.angle = (Math.max(0, p.angle + (currentPlayer ? 1 : -1))) | 0;
    if (keys['ArrowLeft']) p.angle = (Math.min(180, p.angle + (currentPlayer ? -1 : 1))) | 0;
    if (keys['ArrowUp']) p.power = (Math.min(100, p.power + 1)) | 0;
    if (keys['ArrowDown']) p.power = (Math.max(5, p.power - 1)) | 0;
    if (keys[' '] ) { launch(p); keys[' '] = false; }
  }

  // aggiorna proiettile
  if (projectile) {
    projectile.vx += projectile.ax;
    projectile.vy += projectile.ay;
    projectile.x += projectile.vx;
    projectile.y += projectile.vy;
	
	const xidx = Math.floor(projectile.x);
    if (xidx >= 0 && xidx < W) {
      const groundY = H - terrain[xidx];
      if (projectile.y >= groundY) {
        explode(projectile.x, projectile.y, 10);
		projectile = null;
	  }
    }
    if (projectile && (projectile.x < -50 || projectile.x > W+50 || projectile.y > H+50)) {
      projectile = null;
	  nextTurn();
    }
  }
  
  // aggiorna esplosioni radiali
  for (let i = explosions.length - 1; i >= 0; i--) {
    const e = explosions[i];
    e.x += e.vx;
    e.y += e.vy;
    e.life--;
    if (e.life <= 0) explosions.splice(i, 1);
  }
}




//apple2 era un catorcio 6502 ad 1mhz
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

//catorcio deluxe sincrono
function sleepSync(ms) {
  const end = Date.now() + ms;
  while (Date.now() < end) {
    // fa assolutamente nulla
  }
}

// ------------------------------------------------
// DRAW
function draw() {
  //clear
  ctx.fillStyle = COLORS.black;
  ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = COLORS.white;
  ctx.strokeRect(0,0,W,H);

  //terrain
  drawTerrain();

  //players
  players.forEach(p => drawGun(p));
  
  //flag
  drawWindFlag();

  //disegna projectile
  if (projectile) {
    //scia
    ctx.strokeStyle = isBW ? COLORS.green : projectile.owner.color;
    ctx.beginPath();
    ctx.moveTo(projectile.x, projectile.y);
	//+ avanti tipo missile con razzo dietro, - con punta bianca e scia colorata (mahhh)
    ctx.lineTo(projectile.x + projectile.vx * 2, projectile.y + projectile.vy * 2);
	ctx.stroke();
	//punta
	ctx.fillStyle = COLORS.white;
    ctx.fillRect(projectile.x-1, projectile.y-1, 2,2);
  }
  
  //disegna esplosioni radiali
  for (const e of explosions) {
    const alpha = Math.max(0, e.life / 30);
    ctx.strokeStyle = e.color;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(e.x, e.y);
    ctx.lineTo(e.x + e.vx * 30, e.y + e.vy * 30);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
  }

  //hud
  drawHUD();
}

//disegna terreno
function drawTerrain() {
  for (let x=0;x<W;x++){
    const h = terrain[x];
	if(isBW) ctx.fillStyle = (x % 2 === 0) ? COLORS.green : COLORS.darkGreen;
	else ctx.fillStyle = (x % 2 === 0) ? terrainColors[currentTerrainColor] : terrainColors[currentTerrainColorDark];
    ctx.fillRect(x, H - h, 1, h);
	//bordo scuro o neve?
	//ctx.fillStyle = terrainColors[currentTerrainColorDark];
	//ctx.fillRect(x, H - h, 1, 1);
  }
}

//disegna cannoni
function drawGun(p) {
  const y = (H - terrain[p.x]) - 2;
  
  // CORPO del cannone: trapezio rovesciato
  ctx.fillStyle = isBW ? COLORS.white : p.color;
  ctx.beginPath();
  ctx.moveTo(p.x - 5, y);     // punto in alto a sinistra
  ctx.lineTo(p.x + 5, y);     // punto in alto a destra
  ctx.lineTo(p.x + 4, y + 3); // punto in basso a destra
  ctx.lineTo(p.x - 4, y + 3); // punto in basso a sinistra
  ctx.closePath();
  ctx.fill();
  
  // CANNA del cannone
  const a = p.angle * Math.PI / 180;
  const len = 6;
  const dir = (p.x < W/2 ? 1 : -1);
  const bx = p.x + Math.cos(a) * len * dir;
  const by = y - Math.sin(a) * len;
  ctx.beginPath();
  ctx.moveTo(p.x, y);
  ctx.lineTo(bx, by);
  ctx.strokeStyle = isBW ? COLORS.white : p.color;
  ctx.stroke();
}

//disegna bandiera
function drawWindFlag() {
  const flagX = players[1].x + 25;
  const flagY = H - terrain[flagX];//altezza del terreno in quel punto
  
  //disegna asta
  ctx.strokeStyle = COLORS.white;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(flagX, flagY);
  ctx.lineTo(flagX, flagY - 12);
  ctx.stroke();

  //disegna bandiera
  ctx.fillStyle = isBW ? COLORS.white : COLORS.yellow;
  let windIntensity = Math.abs(wind) | 0;
  const rectWidth = windIntensity;
  const rectHeight = 4;

  if (wind >= 0) {
    //bandiera verso destra
    ctx.fillRect(flagX, flagY - 12, rectWidth, rectHeight);
  } else {
    //bandiera verso sinistra
    ctx.fillRect(flagX - rectWidth, flagY - 12, rectWidth, rectHeight);
  }
}

//disegna dati player
function drawHUD() {
  const p = players[currentPlayer];
  
  ctx.font = "10px monospace";
  ctx.textBaseline = "alphabetic";
  
  //player
  ctx.fillStyle = isBW ? COLORS.white : p.color;  
  ctx.fillText(`${p.name}`, 6, H - 12);
  //potenza/angolo
  ctx.fillStyle = COLORS.white;
  ctx.fillText("POWER: " + p.power, 6, H - 2);
  ctx.fillText("ANGLE: " + p.angle, 66, H - 2);
  //vento
  ctx.fillText("WIND: " + (wind > 0 ? '+':'') + wind, 262, H - 2);

  // TURNO CORRENTE
  ctx.fillStyle = COLORS.white;
  ctx.fillText("TURN: " + p.name, 6, H - 24);

  //messaggio
  if (message) {
    ctx.fillStyle = COLORS.white;
    const tw = ctx.measureText(message).width;
    ctx.fillText(message, (W - tw)/2, H - 12);
  }
  
  //titolo dentro con bordi doppi
  if (isDistort) {
	ctx.fillStyle = COLORS.white;//gray;
    const title = "Artillery - Apple ][ clone";
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (W - tw)/2, 14);
	
	ctx.strokeStyle = COLORS.white;
	ctx.lineWidth = 3;
	ctx.strokeRect(0, 0, W, H);
	ctx.strokeStyle = COLORS.gray;
	ctx.lineWidth = 1;
	ctx.strokeRect(3, 3, W-3, H-3);
  }
}



//SUONI
function playExplosionSound() {
	if(isMute) return;
    const now = audioCtx.currentTime;

    // 1. Crea un generatore di Rumore Bianco (Noise Buffer)
    const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 secondi
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1; // Riempie il buffer con rumore casuale (statico)
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    // 2. Crea i nodi di Guadagno e Filtro
    const noiseGain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    // Imposta il filtro per un suono "sordo" e breve (filtro passa basso)
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, now); // Frequenza di taglio iniziale
    filter.frequency.exponentialRampToValueAtTime(10, now + 0.3); // Decadimento rapido della frequenza

    // Connessioni: Rumore -> Filtro -> Guadagno -> Destinazione
    noise.connect(filter);
    filter.connect(noiseGain);
    noiseGain.connect(audioCtx.destination);

    // 3. Envelope (ADSR)
    noiseGain.gain.setValueAtTime(0.5, now); // Volume iniziale
    // Decay rapido del volume (il "botto" finisce subito)
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3); 

    // 4. Avvia e Ferma
    noise.start(now);
    noise.stop(now + 0.3);
}

function playShootSound() {
	if(isMute) return;
    // 1. Crea l'oscillatore (il "generatore di suono")
    const oscillator = audioCtx.createOscillator();
    // Usa un'onda quadra per un suono "pixelato" o un'onda a dente di sega (sawtooth)
    oscillator.type = 'square'; 

    // 2. Crea un nodo del guadagno (Gain Node) per controllare il volume e l'ADSR
    const gainNode = audioCtx.createGain();
    
    // Connetti: Oscillatore -> Guadagno -> Destinazione (altoparlanti)
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    // 3. Imposta la Frequenza Iniziale e Finale (per il "pitch-drop" o "fall")
    const startFreq = 400; // Frequenza iniziale (più alta)
    const endFreq = 200;   // Frequenza finale (più bassa)
    const duration = 0.15; // Durata breve in secondi

    oscillator.frequency.setValueAtTime(startFreq, now);
    // Diminuisci rapidamente la frequenza (effetto laser/sparo 8-bit)
    oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

    // 4. Imposta il Volume (Envelope)
    gainNode.gain.setValueAtTime(0.5, now); // Volume iniziale
    // Riduci rapidamente il volume
    gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); 
    
    // 5. Avvia e Ferma l'oscillatore
    oscillator.start(now);
    oscillator.stop(now + duration);
}

function playTankExplosionSound() {
	if(isMute) return;
    const now = audioCtx.currentTime;
    const duration = 0.5; // Durata maggiore per l'esplosione del carro armato

    // 1. Rumore Bianco (Il "Bot")
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1; 
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const noiseGain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.frequency.exponentialRampToValueAtTime(10, now + duration);

    noise.connect(filter);
    filter.connect(noiseGain);
    
    // 2. Tono Basso (L'effetto "WAAAH")
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'sawtooth'; // Tono più ricco di armoniche
    
    const oscGain = audioCtx.createGain();
    
    // Connessioni per il Tono:
    oscillator.connect(oscGain);

    // Envelope del Tono: Pitch Drop
    oscillator.frequency.setValueAtTime(100, now); // Frequenza iniziale bassa
    oscillator.frequency.exponentialRampToValueAtTime(10, now + duration); // Crolla a 10Hz

    // 3. Unione e Decadimento del Guadagno
    
    // Volume del Rumore
    noiseGain.gain.setValueAtTime(0.6, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + duration); 

    // Volume del Tono
    oscGain.gain.setValueAtTime(0.3, now);
    oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration); 

    // Unisci i due suoni e invia alla destinazione
    noiseGain.connect(audioCtx.destination);
    oscGain.connect(audioCtx.destination);

    // 4. Avvia e Ferma
    noise.start(now);
    noise.stop(now + duration);
    oscillator.start(now);
    oscillator.stop(now + duration);
}

function playBeep() {
	if(isMute) return;
	const oscillator = audioCtx.createOscillator();
	const gain = audioCtx.createGain();

	oscillator.type = 'square'; // Apple II usava un'onda quadra
	oscillator.frequency.setValueAtTime(935, audioCtx.currentTime);
	gain.gain.setValueAtTime(0.2, audioCtx.currentTime);

	oscillator.connect(gain);
	gain.connect(audioCtx.destination);

	oscillator.start();
	oscillator.stop(audioCtx.currentTime + 0.1); // durata 250 ms
}



//gestione scanlines on/off
function changeScanLines() {
	scanLinesEnabled = !scanLinesEnabled;
	const btn = document.getElementById('scanlinesBtn');
	
	if (scanLinesEnabled) {
		btn.classList.add('on');
		document.getElementById('scanlines-overlay').style.display = 'block';
	} else {
		btn.classList.remove('on');
		document.getElementById('scanlines-overlay').style.display = 'none';
	}
}


// ------------------------------------------------
// QUESTO E' IL GIOCO!
function loop() {
  update();
  draw();
  if(isDistort) distort();
  requestAnimationFrame(loop);
}

loop();



//gestione mute sound on/off	
function changeMute() {
	isMute = !isMute;
	const btn = document.getElementById('muteBtn');

	if (isMute) btn.classList.add('on');
	else btn.classList.remove('on');
}

//gestione P2 umano
function changePlayer2Human() {
	players[1].isAI = !(players[1].isAI);
	const btn = document.getElementById('p2humanBtn');
	
	if(players[1].isAI) btn.classList.remove('on');
	else btn.classList.add('on');
}


//gestione crt
function changeCrt() {
	currentCrt = (currentCrt+1) % 3;
	const btn = document.getElementById('crtBtn');
	const container = document.getElementById('container');
	
	if(currentCrt == 0) {
		btn.classList.remove('on');
		container.style.filter = "";
	}
	else if(currentCrt == 1) {
		btn.classList.add('on');
		container.style.filter = "grayscale(1)";
	}
	else {
		btn.classList.add('on');
		container.style.filter = "hue-rotate(280deg)";
	}
}


//gestione hantarex
function changeHantarex() {
    isHantarex = !isHantarex;
	const btn = document.getElementById('hantarexBtn');
	const monitor = document.getElementById('monitor');
	const container = document.getElementById('container');
	
	if (isHantarex) {
		btn.classList.add('on');
		monitor.classList.add('hantarex');
		container.classList.add('hantarex');
	}
	else {
		btn.classList.remove('on');
		monitor.classList.remove('hantarex');
		container.classList.remove('hantarex');
	}
}


//gestione bw
function changeBW() {
	isBW = !isBW;
	const btn = document.getElementById('bwBtn');
	
	if (isBW) {
		btn.classList.add('on');
	}
	else {
		btn.classList.remove('on');
	}
}


//gestione distort
function changeDistort() {
	isDistort = !isDistort;
	const btn = document.getElementById('distortBtn');
	const title = document.getElementById('title');
	const game = document.getElementById('game');
	
	if (isDistort) {
		btn.classList.add('on');
		title.style.display = 'none';
		game.style.border = 'none';
	}
	else {
		btn.classList.remove('on');
		title.style.display = 'block';
		game.style.border = '4px solid #fff';
	}
}

// ------------------------------------------------
// INPUT
window.addEventListener('keydown', e => {
  const key = e.key;
  //alcuni devono funzionare sempre
  if (key === ' ') e.preventDefault();
  if (key === 's' || key === 'S') changeScanLines();
  if (key === 'm' || key === 'M') changeMute();
  if (key === 'c' || key === 'C') changeCrt();
  if (key === 'x' || key === 'X') changeHantarex();
  if (key === 'b' || key === 'B') changeBW();
  if (key === 'd' || key === 'D') changeDistort();
  
  //altri devono funzionare solo quando tocca all'umano
  if (players[currentPlayer].isAI) return;
  if (gameover) return;

  if (key === 'r' || key === 'R') reset();
  if (key === 'h' || key === 'H') changePlayer2Human();
  if (key === 'a' || key === 'A') enterAngle();
  if (key === 'p' || key === 'P') enterPower();
  

  /*
  // Modalità inserimento (TROPPO POCO INTUITIVA)
  if (key === 'a' || key === 'A') {
    inputMode = "angle";
    inputBuffer = "";
  } else if (key === 'p' || key === 'P') {
    inputMode = "power";
    inputBuffer = "";
  } else if (inputMode && /^[0-9]$/.test(key)) {
    inputBuffer += key;
  } else if (inputMode && (key === 'Enter' || key === 'Return')) {
    const value = parseInt(inputBuffer);
    const p = players[currentPlayer];
    if (inputMode === "angle") p.angle = Math.max(0, Math.min(180, value)) | 0;
    if (inputMode === "power") p.power = Math.max(5, Math.min(100, value)) | 0;
    inputMode = null;
    inputBuffer = "";
  }*/
  
  keys[key] = true;
});

//popup orrenda angolo
function enterAngle() {
    let aa = prompt('ENTER ANGLE (0-180)');
	const value = parseInt(aa);
    const p = players[currentPlayer];
    p.angle = Math.max(0, Math.min(180, value)) | 0;
}

//popup orrenda potenza
function enterPower() {
	let pp = prompt('ENTER POWER (0-100)');
	const value = parseInt(pp);
    const p = players[currentPlayer];
    p.power = Math.max(5, Math.min(100, value)) | 0;
}

window.addEventListener('keyup', e=>{ keys[e.key] = false });

//click = spara!
canvas.addEventListener('click', ()=> {
  if (gameover) return;
  if (!players[currentPlayer].isAI) launch(players[currentPlayer]);
});

//doppio click = fullscreen
document.body.addEventListener('dblclick', () => {
	if(document.fullscreenElement) document.exitFullscreen();
	else document.documentElement.requestFullscreen();
});

//gestione touch controls
document.getElementById('touch-controls').addEventListener('click', e => {
  //alcuni devono funzionare sempre
  const btn = e.target.closest('button');
  if (!btn) return;
  const act = btn.dataset.act;
  const p = players[currentPlayer];

  switch (act) {
  	case 'mute': changeMute(); break;
	case 'scanlines': changeScanLines(); break;
    case 'crt': changeCrt(); break;
	case 'hantarex': changeHantarex(); break;
	case 'bw': changeBW(); break;
	case 'distort': changeDistort(); break;
  }
  
  //altri devono funzionare solo quando tocca all'umano
  if (players[currentPlayer].isAI) return;
  if (gameover) return;
  
  switch (act) {
    case 'left':  p.angle = Math.min(180, p.angle + (currentPlayer ? -1 : 1)); break;
    case 'right': p.angle = Math.max(0, p.angle - (currentPlayer ? -1 : 1)); break;
    case 'power-up':   p.power = Math.min(100, p.power + 5); break;
    case 'power-down': p.power = Math.max(5, p.power - 5); break;
    case 'fire': launch(p); break;
    case 'reset': reset(); break;
	case 'p2human': changePlayer2Human(); break;
	case 'power': enterPower(); break;
	case 'angle': enterAngle(); break;
  }
  
  btn.blur();
});


function distort() {
    // ora applichiamo distorsione a barilotto
    const src = ctx.getImageData(0, 0, W, H);
    const dst = ctx.createImageData(W, H);

    const k = -0.00000125; // intensità curvatura (più grande = più curva)
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        const dx = x - W / 2;
        const dy = y - H / 2;
        const r2 = dx * dx + dy * dy;
        const factor = 1 + k * r2; // fattore di curvatura
        const sx = Math.round(W / 2 + dx / factor);
        const sy = Math.round(H / 2 + dy / factor);
        if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
          const sIdx = (sy * W + sx) * 4;
          const dIdx = (y * W + x) * 4;
          dst.data[dIdx] = src.data[sIdx];
          dst.data[dIdx + 1] = src.data[sIdx + 1];
          dst.data[dIdx + 2] = src.data[sIdx + 2];
          dst.data[dIdx + 3] = src.data[sIdx + 3];
        }
      }
    }

    ctx.putImageData(dst, 0, 0);
}

</script>
</body>
</html>